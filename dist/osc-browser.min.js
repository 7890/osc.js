/*! osc.js 2.2.0, Copyright 2017 Colin Clark | github.com/colinbdclark/osc.js */


var osc = osc || {};

!function() {
    "use strict";
    osc.SECS_70YRS = 2208988800, osc.TWO_32 = 4294967296, osc.defaults = {
        metadata: !1,
        unpackSingleArgs: !0
    }, osc.isCommonJS = !("undefined" == typeof module || !module.exports), osc.isNode = osc.isCommonJS && "undefined" == typeof window, 
    osc.isElectron = !("undefined" == typeof process || !process.versions || !process.versions.electron), 
    osc.isBufferEnv = osc.isNode || osc.isElectron, osc.isArray = function(e) {
        return e && "[object Array]" === Object.prototype.toString.call(e);
    }, osc.isTypedArrayView = function(e) {
        return e.buffer && e.buffer instanceof ArrayBuffer;
    }, osc.isBuffer = function(e) {
        return osc.isBufferEnv && e instanceof Buffer;
    };
    var e = "undefined" != typeof dcodeIO ? dcodeIO.Long : void 0 !== e ? e : osc.isNode ? require("long") : void 0;
    osc.dataView = function(e, t, r) {
        return e.buffer ? new DataView(e.buffer, t, r) : e instanceof ArrayBuffer ? new DataView(e, t, r) : new DataView(new Uint8Array(e), t, r);
    }, osc.byteArray = function(e) {
        if (e instanceof Uint8Array) return e;
        var t = e.buffer ? e.buffer : e;
        if (!(t instanceof ArrayBuffer || void 0 !== t.length && "string" != typeof t)) throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " + JSON.stringify(e, null, 2));
        return new Uint8Array(t);
    }, osc.nativeBuffer = function(e) {
        return osc.isBufferEnv ? osc.isBuffer(e) ? e : new Buffer(e.buffer ? e : new Uint8Array(e)) : osc.isTypedArrayView(e) ? e : new Uint8Array(e);
    }, osc.copyByteArray = function(e, t, r) {
        if (osc.isTypedArrayView(e) && osc.isTypedArrayView(t)) t.set(e, r); else for (var n = void 0 === r ? 0 : r, i = Math.min(t.length - r, e.length), s = 0, o = n; s < i; s++, 
        o++) t[o] = e[s];
        return t;
    }, osc.readString = function(e, t) {
        for (var r = [], n = t.idx; n < e.byteLength; n++) {
            var i = e.getUint8(n);
            if (0 === i) {
                n++;
                break;
            }
            r.push(i);
        }
        return n = n + 3 & -4, t.idx = n, String.fromCharCode.apply(null, r);
    }, osc.writeString = function(e) {
        for (var t = e + "\0", r = t.length + 3 & -4, n = new Uint8Array(r), i = 0; i < t.length; i++) {
            var s = t.charCodeAt(i);
            n[i] = s;
        }
        return n;
    }, osc.readPrimitive = function(e, t, r, n) {
        var i = e[t](n.idx, !1);
        return n.idx += r, i;
    }, osc.writePrimitive = function(e, t, r, n, i) {
        i = void 0 === i ? 0 : i;
        var s;
        return t ? s = new Uint8Array(t.buffer) : (s = new Uint8Array(n), t = new DataView(s.buffer)), 
        t[r](i, e, !1), s;
    }, osc.readInt32 = function(e, t) {
        return osc.readPrimitive(e, "getInt32", 4, t);
    }, osc.writeInt32 = function(e, t, r) {
        return osc.writePrimitive(e, t, "setInt32", 4, r);
    }, osc.readInt64 = function(t, r) {
        var n = osc.readPrimitive(t, "getInt32", 4, r), i = osc.readPrimitive(t, "getInt32", 4, r);
        return e ? new e(i, n) : {
            high: n,
            low: i,
            unsigned: !1
        };
    }, osc.writeInt64 = function(e, t, r) {
        var n = new Uint8Array(8);
        return n.set(osc.writePrimitive(e.high, t, "setInt32", 4, r), 0), n.set(osc.writePrimitive(e.low, t, "setInt32", 4, r + 4), 4), 
        n;
    }, osc.readFloat32 = function(e, t) {
        return osc.readPrimitive(e, "getFloat32", 4, t);
    }, osc.writeFloat32 = function(e, t, r) {
        return osc.writePrimitive(e, t, "setFloat32", 4, r);
    }, osc.readFloat64 = function(e, t) {
        return osc.readPrimitive(e, "getFloat64", 8, t);
    }, osc.writeFloat64 = function(e, t, r) {
        return osc.writePrimitive(e, t, "setFloat64", 8, r);
    }, osc.readChar32 = function(e, t) {
        var r = osc.readPrimitive(e, "getUint32", 4, t);
        return String.fromCharCode(r);
    }, osc.writeChar32 = function(e, t, r) {
        var n = e.charCodeAt(0);
        if (!(void 0 === n || n < -1)) return osc.writePrimitive(n, t, "setUint32", 4, r);
    }, osc.readBlob = function(e, t) {
        var r = osc.readInt32(e, t), n = r + 3 & -4, i = new Uint8Array(e.buffer, t.idx, r);
        return t.idx += n, i;
    }, osc.writeBlob = function(e) {
        var t = (e = osc.byteArray(e)).byteLength, r = (t + 3 & -4) + 4, n = new Uint8Array(r), i = new DataView(n.buffer);
        return osc.writeInt32(t, i), n.set(e, 4), n;
    }, osc.readMIDIBytes = function(e, t) {
        var r = new Uint8Array(e.buffer, t.idx, 4);
        return t.idx += 4, r;
    }, osc.writeMIDIBytes = function(e) {
        e = osc.byteArray(e);
        var t = new Uint8Array(4);
        return t.set(e), t;
    }, osc.readColor = function(e, t) {
        var r = new Uint8Array(e.buffer, t.idx, 4), n = r[3] / 255;
        return t.idx += 4, {
            r: r[0],
            g: r[1],
            b: r[2],
            a: n
        };
    }, osc.writeColor = function(e) {
        var t = Math.round(255 * e.a);
        return new Uint8Array([ e.r, e.g, e.b, t ]);
    }, osc.readTrue = function() {
        return !0;
    }, osc.readFalse = function() {
        return !1;
    }, osc.readNull = function() {
        return null;
    }, osc.readImpulse = function() {
        return 1;
    }, osc.readTimeTag = function(e, t) {
        var r = osc.readPrimitive(e, "getUint32", 4, t), n = osc.readPrimitive(e, "getUint32", 4, t);
        return {
            raw: [ r, n ],
            native: 0 === r && 1 === n ? Date.now() : osc.ntpToJSTime(r, n)
        };
    }, osc.writeTimeTag = function(e) {
        var t = e.raw ? e.raw : osc.jsToNTPTime(e.native), r = new Uint8Array(8), n = new DataView(r.buffer);
        return osc.writeInt32(t[0], n, 0), osc.writeInt32(t[1], n, 4), r;
    }, osc.timeTag = function(e, t) {
        e = e || 0;
        var r = (t = t || Date.now()) / 1e3, n = Math.floor(r), i = r - n, s = Math.floor(e), o = i + (e - s);
        if (o > 1) {
            var a = Math.floor(o);
            s += a, o = o - a;
        }
        return {
            raw: [ n + s + osc.SECS_70YRS, Math.round(osc.TWO_32 * o) ]
        };
    }, osc.ntpToJSTime = function(e, t) {
        return 1e3 * (e - osc.SECS_70YRS + t / osc.TWO_32);
    }, osc.jsToNTPTime = function(e) {
        var t = e / 1e3, r = Math.floor(t), n = t - r;
        return [ r + osc.SECS_70YRS, Math.round(osc.TWO_32 * n) ];
    }, osc.readArguments = function(e, t, r) {
        var n = osc.readString(e, r);
        if (0 !== n.indexOf(",")) throw new Error("A malformed type tag string was found while reading the arguments of an OSC message. String was: " + n, " at offset: " + r.idx);
        var i = n.substring(1).split(""), s = [];
        return osc.readArgumentsIntoArray(s, i, n, e, t, r), s;
    }, osc.readArgument = function(e, t, r, n, i) {
        var s = osc.argumentTypes[e];
        if (!s) throw new Error("'" + e + "' is not a valid OSC type tag. Type tag string was: " + t);
        var o = s.reader, a = osc[o](r, i);
        return n.metadata && (a = {
            type: e,
            value: a
        }), a;
    }, osc.readArgumentsIntoArray = function(e, t, r, n, i, s) {
        for (var o = 0; o < t.length; ) {
            var a, u = t[o];
            if ("[" === u) {
                var c = t.slice(o + 1), h = c.indexOf("]");
                if (h < 0) throw new Error("Invalid argument type tag: an open array type tag ('[') was found without a matching close array tag ('[]'). Type tag was: " + r);
                var f = c.slice(0, h);
                a = osc.readArgumentsIntoArray([], f, r, n, i, s), o += h + 2;
            } else a = osc.readArgument(u, r, n, i, s), o++;
            e.push(a);
        }
        return e;
    }, osc.writeArguments = function(e, t) {
        var r = osc.collectArguments(e, t);
        return osc.joinParts(r);
    }, osc.joinParts = function(e) {
        for (var t = new Uint8Array(e.byteLength), r = e.parts, n = 0, i = 0; i < r.length; i++) {
            var s = r[i];
            osc.copyByteArray(s, t, n), n += s.length;
        }
        return t;
    }, osc.addDataPart = function(e, t) {
        t.parts.push(e), t.byteLength += e.length;
    }, osc.writeArrayArguments = function(e, t) {
        for (var r = "[", n = 0; n < e.length; n++) {
            var i = e[n];
            r += osc.writeArgument(i, t);
        }
        return r += "]";
    }, osc.writeArgument = function(e, t) {
        if (osc.isArray(e)) return osc.writeArrayArguments(e, t);
        var r = e.type, n = osc.argumentTypes[r].writer;
        if (n) {
            var i = osc[n](e.value);
            osc.addDataPart(i, t);
        }
        return e.type;
    }, osc.collectArguments = function(e, t, r) {
        osc.isArray(e) || (e = void 0 === e ? [] : [ e ]), r = r || {
            byteLength: 0,
            parts: []
        }, t.metadata || (e = osc.annotateArguments(e));
        for (var n = ",", i = r.parts.length, s = 0; s < e.length; s++) {
            var o = e[s];
            n += osc.writeArgument(o, r);
        }
        var a = osc.writeString(n);
        return r.byteLength += a.byteLength, r.parts.splice(i, 0, a), r;
    }, osc.readMessage = function(e, t, r) {
        t = t || osc.defaults;
        var n = osc.dataView(e, e.byteOffset, e.byteLength);
        r = r || {
            idx: 0
        };
        var i = osc.readString(n, r);
        return osc.readMessageContents(i, n, t, r);
    }, osc.readMessageContents = function(e, t, r, n) {
        if (0 !== e.indexOf("/")) throw new Error("A malformed OSC address was found while reading an OSC message. String was: " + e);
        var i = osc.readArguments(t, r, n);
        return {
            address: e,
            args: 1 === i.length && r.unpackSingleArgs ? i[0] : i
        };
    }, osc.collectMessageParts = function(e, t, r) {
        return r = r || {
            byteLength: 0,
            parts: []
        }, osc.addDataPart(osc.writeString(e.address), r), osc.collectArguments(e.args, t, r);
    }, osc.writeMessage = function(e, t) {
        if (t = t || osc.defaults, !osc.isValidMessage(e)) throw new Error("An OSC message must contain a valid address. Message was: " + JSON.stringify(e, null, 2));
        var r = osc.collectMessageParts(e, t);
        return osc.joinParts(r);
    }, osc.isValidMessage = function(e) {
        return e.address && 0 === e.address.indexOf("/");
    }, osc.readBundle = function(e, t, r) {
        return osc.readPacket(e, t, r);
    }, osc.collectBundlePackets = function(e, t, r) {
        r = r || {
            byteLength: 0,
            parts: []
        }, osc.addDataPart(osc.writeString("#bundle"), r), osc.addDataPart(osc.writeTimeTag(e.timeTag), r);
        for (var n = 0; n < e.packets.length; n++) {
            var i = e.packets[n], s = (i.address ? osc.collectMessageParts : osc.collectBundlePackets)(i, t);
            r.byteLength += s.byteLength, osc.addDataPart(osc.writeInt32(s.byteLength), r), 
            r.parts = r.parts.concat(s.parts);
        }
        return r;
    }, osc.writeBundle = function(e, t) {
        if (!osc.isValidBundle(e)) throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. Bundle was: " + JSON.stringify(e, null, 2));
        t = t || osc.defaults;
        var r = osc.collectBundlePackets(e, t);
        return osc.joinParts(r);
    }, osc.isValidBundle = function(e) {
        return void 0 !== e.timeTag && void 0 !== e.packets;
    }, osc.readBundleContents = function(e, t, r, n) {
        for (var i = osc.readTimeTag(e, r), s = []; r.idx < n; ) {
            var o = osc.readInt32(e, r), a = r.idx + o, u = osc.readPacket(e, t, r, a);
            s.push(u);
        }
        return {
            timeTag: i,
            packets: s
        };
    }, osc.readPacket = function(e, t, r, n) {
        var i = osc.dataView(e, e.byteOffset, e.byteLength);
        n = void 0 === n ? i.byteLength : n, r = r || {
            idx: 0
        };
        var s = osc.readString(i, r), o = s[0];
        if ("#" === o) return osc.readBundleContents(i, t, r, n);
        if ("/" === o) return osc.readMessageContents(s, i, t, r);
        throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string. Header was: " + s);
    }, osc.writePacket = function(e, t) {
        if (osc.isValidMessage(e)) return osc.writeMessage(e, t);
        if (osc.isValidBundle(e)) return osc.writeBundle(e, t);
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle. Packet was: " + JSON.stringify(e, null, 2));
    }, osc.argumentTypes = {
        i: {
            reader: "readInt32",
            writer: "writeInt32"
        },
        h: {
            reader: "readInt64",
            writer: "writeInt64"
        },
        f: {
            reader: "readFloat32",
            writer: "writeFloat32"
        },
        s: {
            reader: "readString",
            writer: "writeString"
        },
        S: {
            reader: "readString",
            writer: "writeString"
        },
        b: {
            reader: "readBlob",
            writer: "writeBlob"
        },
        t: {
            reader: "readTimeTag",
            writer: "writeTimeTag"
        },
        T: {
            reader: "readTrue"
        },
        F: {
            reader: "readFalse"
        },
        N: {
            reader: "readNull"
        },
        I: {
            reader: "readImpulse"
        },
        d: {
            reader: "readFloat64",
            writer: "writeFloat64"
        },
        c: {
            reader: "readChar32",
            writer: "writeChar32"
        },
        r: {
            reader: "readColor",
            writer: "writeColor"
        },
        m: {
            reader: "readMIDIBytes",
            writer: "writeMIDIBytes"
        }
    }, osc.inferTypeForArgument = function(e) {
        switch (typeof e) {
          case "boolean":
            return e ? "T" : "F";

          case "string":
            return "s";

          case "number":
            return "f";

          case "undefined":
            return "N";

          case "object":
            if (null === e) return "N";
            if (e instanceof Uint8Array || e instanceof ArrayBuffer) return "b";
            if ("number" == typeof e.high && "number" == typeof e.low) return "h";
        }
        throw new Error("Can't infer OSC argument type for value: " + JSON.stringify(e, null, 2));
    }, osc.annotateArguments = function(e) {
        for (var t = [], r = 0; r < e.length; r++) {
            var n, i = e[r];
            n = "object" == typeof i && i.type && void 0 !== i.value ? i : osc.isArray(i) ? osc.annotateArguments(i) : {
                type: osc.inferTypeForArgument(i),
                value: i
            }, t.push(n);
        }
        return t;
    }, osc.isCommonJS && (module.exports = osc);
}(), function(e, t) {
    "function" == typeof define && define.amd ? define([], t) : "function" == typeof require && "object" == typeof module && module && module.exports ? module.exports = t() : (e.dcodeIO = e.dcodeIO || {}).Long = t();
}(this, function() {
    "use strict";
    function e(e, t, r) {
        this.low = 0 | e, this.high = 0 | t, this.unsigned = !!r;
    }
    function t(e) {
        return !0 === (e && e.__isLong__);
    }
    function r(e, t) {
        var r, n, s;
        return t ? (e >>>= 0, (s = 0 <= e && e < 256) && (n = u[e]) ? n : (r = i(e, (0 | e) < 0 ? -1 : 0, !0), 
        s && (u[e] = r), r)) : (e |= 0, (s = -128 <= e && e < 128) && (n = a[e]) ? n : (r = i(e, e < 0 ? -1 : 0, !1), 
        s && (a[e] = r), r));
    }
    function n(e, t) {
        if (isNaN(e) || !isFinite(e)) return t ? p : l;
        if (t) {
            if (e < 0) return p;
            if (e >= f) return b;
        } else {
            if (e <= -d) return S;
            if (e + 1 >= d) return w;
        }
        return e < 0 ? n(-e, t).neg() : i(e % h | 0, e / h | 0, t);
    }
    function i(t, r, n) {
        return new e(t, r, n);
    }
    function s(e, t, r) {
        if (0 === e.length) throw Error("empty string");
        if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return l;
        if ("number" == typeof t ? (r = t, t = !1) : t = !!t, (r = r || 10) < 2 || 36 < r) throw RangeError("radix");
        var i;
        if ((i = e.indexOf("-")) > 0) throw Error("interior hyphen");
        if (0 === i) return s(e.substring(1), t, r).neg();
        for (var o = n(c(r, 8)), a = l, u = 0; u < e.length; u += 8) {
            var h = Math.min(8, e.length - u), f = parseInt(e.substring(u, u + h), r);
            if (h < 8) {
                var d = n(c(r, h));
                a = a.mul(d).add(n(f));
            } else a = (a = a.mul(o)).add(n(f));
        }
        return a.unsigned = t, a;
    }
    function o(t) {
        return t instanceof e ? t : "number" == typeof t ? n(t) : "string" == typeof t ? s(t) : i(t.low, t.high, t.unsigned);
    }
    e.prototype.__isLong__, Object.defineProperty(e.prototype, "__isLong__", {
        value: !0,
        enumerable: !1,
        configurable: !1
    }), e.isLong = t;
    var a = {}, u = {};
    e.fromInt = r, e.fromNumber = n, e.fromBits = i;
    var c = Math.pow;
    e.fromString = s, e.fromValue = o;
    var h = 4294967296, f = h * h, d = f / 2, g = r(1 << 24), l = r(0);
    e.ZERO = l;
    var p = r(0, !0);
    e.UZERO = p;
    var v = r(1);
    e.ONE = v;
    var y = r(1, !0);
    e.UONE = y;
    var m = r(-1);
    e.NEG_ONE = m;
    var w = i(-1, 2147483647, !1);
    e.MAX_VALUE = w;
    var b = i(-1, -1, !0);
    e.MAX_UNSIGNED_VALUE = b;
    var S = i(0, -2147483648, !1);
    e.MIN_VALUE = S;
    var E = e.prototype;
    return E.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
    }, E.toNumber = function() {
        return this.unsigned ? (this.high >>> 0) * h + (this.low >>> 0) : this.high * h + (this.low >>> 0);
    }, E.toString = function(e) {
        if ((e = e || 10) < 2 || 36 < e) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
            if (this.eq(S)) {
                var t = n(e), r = this.div(t), i = r.mul(t).sub(this);
                return r.toString(e) + i.toInt().toString(e);
            }
            return "-" + this.neg().toString(e);
        }
        for (var s = n(c(e, 6), this.unsigned), o = this, a = ""; ;) {
            var u = o.div(s), h = (o.sub(u.mul(s)).toInt() >>> 0).toString(e);
            if ((o = u).isZero()) return h + a;
            for (;h.length < 6; ) h = "0" + h;
            a = "" + h + a;
        }
    }, E.getHighBits = function() {
        return this.high;
    }, E.getHighBitsUnsigned = function() {
        return this.high >>> 0;
    }, E.getLowBits = function() {
        return this.low;
    }, E.getLowBitsUnsigned = function() {
        return this.low >>> 0;
    }, E.getNumBitsAbs = function() {
        if (this.isNegative()) return this.eq(S) ? 64 : this.neg().getNumBitsAbs();
        for (var e = 0 != this.high ? this.high : this.low, t = 31; t > 0 && 0 == (e & 1 << t); t--) ;
        return 0 != this.high ? t + 33 : t + 1;
    }, E.isZero = function() {
        return 0 === this.high && 0 === this.low;
    }, E.isNegative = function() {
        return !this.unsigned && this.high < 0;
    }, E.isPositive = function() {
        return this.unsigned || this.high >= 0;
    }, E.isOdd = function() {
        return 1 == (1 & this.low);
    }, E.isEven = function() {
        return 0 == (1 & this.low);
    }, E.equals = function(e) {
        return t(e) || (e = o(e)), (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && (this.high === e.high && this.low === e.low);
    }, E.eq = E.equals, E.notEquals = function(e) {
        return !this.eq(e);
    }, E.neq = E.notEquals, E.lessThan = function(e) {
        return this.comp(e) < 0;
    }, E.lt = E.lessThan, E.lessThanOrEqual = function(e) {
        return this.comp(e) <= 0;
    }, E.lte = E.lessThanOrEqual, E.greaterThan = function(e) {
        return this.comp(e) > 0;
    }, E.gt = E.greaterThan, E.greaterThanOrEqual = function(e) {
        return this.comp(e) >= 0;
    }, E.gte = E.greaterThanOrEqual, E.compare = function(e) {
        if (t(e) || (e = o(e)), this.eq(e)) return 0;
        var r = this.isNegative(), n = e.isNegative();
        return r && !n ? -1 : !r && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
    }, E.comp = E.compare, E.negate = function() {
        return !this.unsigned && this.eq(S) ? S : this.not().add(v);
    }, E.neg = E.negate, E.add = function(e) {
        t(e) || (e = o(e));
        var r = this.high >>> 16, n = 65535 & this.high, s = this.low >>> 16, a = 65535 & this.low, u = e.high >>> 16, c = 65535 & e.high, h = e.low >>> 16, f = 0, d = 0, g = 0, l = 0;
        return l += a + (65535 & e.low), g += l >>> 16, l &= 65535, g += s + h, d += g >>> 16, 
        g &= 65535, d += n + c, f += d >>> 16, d &= 65535, f += r + u, f &= 65535, i(g << 16 | l, f << 16 | d, this.unsigned);
    }, E.subtract = function(e) {
        return t(e) || (e = o(e)), this.add(e.neg());
    }, E.sub = E.subtract, E.multiply = function(e) {
        if (this.isZero()) return l;
        if (t(e) || (e = o(e)), e.isZero()) return l;
        if (this.eq(S)) return e.isOdd() ? S : l;
        if (e.eq(S)) return this.isOdd() ? S : l;
        if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
        if (e.isNegative()) return this.mul(e.neg()).neg();
        if (this.lt(g) && e.lt(g)) return n(this.toNumber() * e.toNumber(), this.unsigned);
        var r = this.high >>> 16, s = 65535 & this.high, a = this.low >>> 16, u = 65535 & this.low, c = e.high >>> 16, h = 65535 & e.high, f = e.low >>> 16, d = 65535 & e.low, p = 0, v = 0, y = 0, m = 0;
        return m += u * d, y += m >>> 16, m &= 65535, y += a * d, v += y >>> 16, y &= 65535, 
        y += u * f, v += y >>> 16, y &= 65535, v += s * d, p += v >>> 16, v &= 65535, v += a * f, 
        p += v >>> 16, v &= 65535, v += u * h, p += v >>> 16, v &= 65535, p += r * d + s * f + a * h + u * c, 
        p &= 65535, i(y << 16 | m, p << 16 | v, this.unsigned);
    }, E.mul = E.multiply, E.divide = function(e) {
        if (t(e) || (e = o(e)), e.isZero()) throw Error("division by zero");
        if (this.isZero()) return this.unsigned ? p : l;
        var r, i, s;
        if (this.unsigned) {
            if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return p;
            if (e.gt(this.shru(1))) return y;
            s = p;
        } else {
            if (this.eq(S)) return e.eq(v) || e.eq(m) ? S : e.eq(S) ? v : (r = this.shr(1).div(e).shl(1)).eq(l) ? e.isNegative() ? v : m : (i = this.sub(e.mul(r)), 
            s = r.add(i.div(e)));
            if (e.eq(S)) return this.unsigned ? p : l;
            if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
            if (e.isNegative()) return this.div(e.neg()).neg();
            s = l;
        }
        for (i = this; i.gte(e); ) {
            r = Math.max(1, Math.floor(i.toNumber() / e.toNumber()));
            for (var a = Math.ceil(Math.log(r) / Math.LN2), u = a <= 48 ? 1 : c(2, a - 48), h = n(r), f = h.mul(e); f.isNegative() || f.gt(i); ) f = (h = n(r -= u, this.unsigned)).mul(e);
            h.isZero() && (h = v), s = s.add(h), i = i.sub(f);
        }
        return s;
    }, E.div = E.divide, E.modulo = function(e) {
        return t(e) || (e = o(e)), this.sub(this.div(e).mul(e));
    }, E.mod = E.modulo, E.not = function() {
        return i(~this.low, ~this.high, this.unsigned);
    }, E.and = function(e) {
        return t(e) || (e = o(e)), i(this.low & e.low, this.high & e.high, this.unsigned);
    }, E.or = function(e) {
        return t(e) || (e = o(e)), i(this.low | e.low, this.high | e.high, this.unsigned);
    }, E.xor = function(e) {
        return t(e) || (e = o(e)), i(this.low ^ e.low, this.high ^ e.high, this.unsigned);
    }, E.shiftLeft = function(e) {
        return t(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? i(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : i(0, this.low << e - 32, this.unsigned);
    }, E.shl = E.shiftLeft, E.shiftRight = function(e) {
        return t(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? i(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : i(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, E.shr = E.shiftRight, E.shiftRightUnsigned = function(e) {
        if (t(e) && (e = e.toInt()), 0 === (e &= 63)) return this;
        var r = this.high;
        return e < 32 ? i(this.low >>> e | r << 32 - e, r >>> e, this.unsigned) : 32 === e ? i(r, 0, this.unsigned) : i(r >>> e - 32, 0, this.unsigned);
    }, E.shru = E.shiftRightUnsigned, E.toSigned = function() {
        return this.unsigned ? i(this.low, this.high, !1) : this;
    }, E.toUnsigned = function() {
        return this.unsigned ? this : i(this.low, this.high, !0);
    }, E.toBytes = function(e) {
        return e ? this.toBytesLE() : this.toBytesBE();
    }, E.toBytesLE = function() {
        var e = this.high, t = this.low;
        return [ 255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255, 255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24 & 255 ];
    }, E.toBytesBE = function() {
        var e = this.high, t = this.low;
        return [ e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t ];
    }, e;
}), function(e, t) {
    "use strict";
    "object" == typeof exports ? (e.slip = exports, t(exports)) : "function" == typeof define && define.amd ? define([ "exports" ], function(r) {
        return e.slip = r, e.slip, t(r);
    }) : (e.slip = {}, t(e.slip));
}(this, function(e) {
    "use strict";
    var t = e;
    t.END = 192, t.ESC = 219, t.ESC_END = 220, t.ESC_ESC = 221, t.byteArray = function(e, t, r) {
        return e instanceof ArrayBuffer ? new Uint8Array(e, t, r) : e;
    }, t.expandByteArray = function(e) {
        var t = new Uint8Array(2 * e.length);
        return t.set(e), t;
    }, t.sliceByteArray = function(e, t, r) {
        var n = e.buffer.slice ? e.buffer.slice(t, r) : e.subarray(t, r);
        return new Uint8Array(n);
    }, t.encode = function(e, r) {
        (r = r || {}).bufferPadding = r.bufferPadding || 4;
        var n = (e = t.byteArray(e, r.offset, r.byteLength)).length + r.bufferPadding + 3 & -4, i = new Uint8Array(n), s = 1;
        i[0] = t.END;
        for (var o = 0; o < e.length; o++) {
            s > i.length - 3 && (i = t.expandByteArray(i));
            var a = e[o];
            a === t.END ? (i[s++] = t.ESC, a = t.ESC_END) : a === t.ESC && (i[s++] = t.ESC, 
            a = t.ESC_ESC), i[s++] = a;
        }
        return i[s] = t.END, t.sliceByteArray(i, 0, s + 1);
    }, t.Decoder = function(e) {
        e = "function" != typeof e ? e || {} : {
            onMessage: e
        }, this.maxMessageSize = e.maxMessageSize || 10485760, this.bufferSize = e.bufferSize || 1024, 
        this.msgBuffer = new Uint8Array(this.bufferSize), this.msgBufferIdx = 0, this.onMessage = e.onMessage, 
        this.onError = e.onError, this.escape = !1;
    };
    var r = t.Decoder.prototype;
    return r.decode = function(e) {
        e = t.byteArray(e);
        for (var r, n = 0; n < e.length; n++) {
            var i = e[n];
            if (this.escape) i === t.ESC_ESC ? i = t.ESC : i === t.ESC_END && (i = t.END); else {
                if (i === t.ESC) {
                    this.escape = !0;
                    continue;
                }
                if (i === t.END) {
                    r = this.handleEnd();
                    continue;
                }
            }
            this.addByte(i) || this.handleMessageMaxError();
        }
        return r;
    }, r.handleMessageMaxError = function() {
        this.onError && this.onError(this.msgBuffer.subarray(0), "The message is too large; the maximum message size is " + this.maxMessageSize / 1024 + "KB. Use a larger maxMessageSize if necessary."), 
        this.msgBufferIdx = 0, this.escape = !1;
    }, r.addByte = function(e) {
        return this.msgBufferIdx > this.msgBuffer.length - 1 && (this.msgBuffer = t.expandByteArray(this.msgBuffer)), 
        this.msgBuffer[this.msgBufferIdx++] = e, this.escape = !1, this.msgBuffer.length < this.maxMessageSize;
    }, r.handleEnd = function() {
        if (0 !== this.msgBufferIdx) {
            var e = t.sliceByteArray(this.msgBuffer, 0, this.msgBufferIdx);
            return this.onMessage && this.onMessage(e), this.msgBufferIdx = 0, e;
        }
    }, t;
}), function(e) {
    "use strict";
    function t() {}
    function r(e, t) {
        for (var r = e.length; r--; ) if (e[r].listener === t) return r;
        return -1;
    }
    function n(e) {
        return function() {
            return this[e].apply(this, arguments);
        };
    }
    function i(e) {
        return "function" == typeof e || e instanceof RegExp || !(!e || "object" != typeof e) && i(e.listener);
    }
    var s = t.prototype, o = e.EventEmitter;
    s.getListeners = function(e) {
        var t, r, n = this._getEvents();
        if (e instanceof RegExp) {
            t = {};
            for (r in n) n.hasOwnProperty(r) && e.test(r) && (t[r] = n[r]);
        } else t = n[e] || (n[e] = []);
        return t;
    }, s.flattenListeners = function(e) {
        var t, r = [];
        for (t = 0; t < e.length; t += 1) r.push(e[t].listener);
        return r;
    }, s.getListenersAsObject = function(e) {
        var t, r = this.getListeners(e);
        return r instanceof Array && ((t = {})[e] = r), t || r;
    }, s.addListener = function(e, t) {
        if (!i(t)) throw new TypeError("listener must be a function");
        var n, s = this.getListenersAsObject(e), o = "object" == typeof t;
        for (n in s) s.hasOwnProperty(n) && -1 === r(s[n], t) && s[n].push(o ? t : {
            listener: t,
            once: !1
        });
        return this;
    }, s.on = n("addListener"), s.addOnceListener = function(e, t) {
        return this.addListener(e, {
            listener: t,
            once: !0
        });
    }, s.once = n("addOnceListener"), s.defineEvent = function(e) {
        return this.getListeners(e), this;
    }, s.defineEvents = function(e) {
        for (var t = 0; t < e.length; t += 1) this.defineEvent(e[t]);
        return this;
    }, s.removeListener = function(e, t) {
        var n, i, s = this.getListenersAsObject(e);
        for (i in s) s.hasOwnProperty(i) && -1 !== (n = r(s[i], t)) && s[i].splice(n, 1);
        return this;
    }, s.off = n("removeListener"), s.addListeners = function(e, t) {
        return this.manipulateListeners(!1, e, t);
    }, s.removeListeners = function(e, t) {
        return this.manipulateListeners(!0, e, t);
    }, s.manipulateListeners = function(e, t, r) {
        var n, i, s = e ? this.removeListener : this.addListener, o = e ? this.removeListeners : this.addListeners;
        if ("object" != typeof t || t instanceof RegExp) for (n = r.length; n--; ) s.call(this, t, r[n]); else for (n in t) t.hasOwnProperty(n) && (i = t[n]) && ("function" == typeof i ? s.call(this, n, i) : o.call(this, n, i));
        return this;
    }, s.removeEvent = function(e) {
        var t, r = typeof e, n = this._getEvents();
        if ("string" === r) delete n[e]; else if (e instanceof RegExp) for (t in n) n.hasOwnProperty(t) && e.test(t) && delete n[t]; else delete this._events;
        return this;
    }, s.removeAllListeners = n("removeEvent"), s.emitEvent = function(e, t) {
        var r, n, i, s, o = this.getListenersAsObject(e);
        for (s in o) if (o.hasOwnProperty(s)) for (r = o[s].slice(0), i = 0; i < r.length; i++) !0 === (n = r[i]).once && this.removeListener(e, n.listener), 
        n.listener.apply(this, t || []) === this._getOnceReturnValue() && this.removeListener(e, n.listener);
        return this;
    }, s.trigger = n("emitEvent"), s.emit = function(e) {
        var t = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(e, t);
    }, s.setOnceReturnValue = function(e) {
        return this._onceReturnValue = e, this;
    }, s._getOnceReturnValue = function() {
        return !this.hasOwnProperty("_onceReturnValue") || this._onceReturnValue;
    }, s._getEvents = function() {
        return this._events || (this._events = {});
    }, t.noConflict = function() {
        return e.EventEmitter = o, t;
    }, "function" == typeof define && define.amd ? define(function() {
        return t;
    }) : "object" == typeof module && module.exports ? module.exports = t : e.EventEmitter = t;
}(this || {});

var osc = osc || require("./osc.js"), slip = slip || require("slip"), EventEmitter = EventEmitter || require("events").EventEmitter;

!function() {
    "use strict";
    osc.firePacketEvents = function(e, t, r, n) {
        t.address ? e.emit("message", t, r, n) : osc.fireBundleEvents(e, t, r, n);
    }, osc.fireBundleEvents = function(e, t, r, n) {
        e.emit("bundle", t, r, n);
        for (var i = 0; i < t.packets.length; i++) {
            var s = t.packets[i];
            osc.firePacketEvents(e, s, t.timeTag, n);
        }
    }, osc.fireClosedPortSendError = function(e, t) {
        t = t || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().", 
        e.emit("error", t);
    }, osc.Port = function(e) {
        this.options = e || {}, this.on("data", this.decodeOSC.bind(this));
    };
    var e = osc.Port.prototype = Object.create(EventEmitter.prototype);
    e.constructor = osc.Port, e.send = function(e) {
        var t = Array.prototype.slice.call(arguments), r = this.encodeOSC(e), n = osc.nativeBuffer(r);
        t[0] = n, this.sendRaw.apply(this, t);
    }, e.encodeOSC = function(e) {
        e = e.buffer ? e.buffer : e;
        var t;
        try {
            t = osc.writePacket(e, this.options);
        } catch (e) {
            this.emit("error", e);
        }
        return t;
    }, e.decodeOSC = function(e, t) {
        e = osc.byteArray(e), this.emit("raw", e, t);
        try {
            var r = osc.readPacket(e, this.options);
            this.emit("osc", r, t), osc.firePacketEvents(this, r, void 0, t);
        } catch (e) {
            this.emit("error", e);
        }
    }, osc.SLIPPort = function(e) {
        var t = this, r = this.options = e || {};
        r.useSLIP = void 0 === r.useSLIP || r.useSLIP, this.decoder = new slip.Decoder({
            onMessage: this.decodeOSC.bind(this),
            onError: function(e) {
                t.emit("error", e);
            }
        });
        var n = r.useSLIP ? this.decodeSLIPData : this.decodeOSC;
        this.on("data", n.bind(this));
    }, (e = osc.SLIPPort.prototype = Object.create(osc.Port.prototype)).constructor = osc.SLIPPort, 
    e.encodeOSC = function(e) {
        e = e.buffer ? e.buffer : e;
        var t;
        try {
            var r = osc.writePacket(e, this.options);
            t = slip.encode(r);
        } catch (e) {
            this.emit("error", e);
        }
        return t;
    }, e.decodeSLIPData = function(e, t) {
        this.decoder.decode(e, t);
    }, osc.relay = function(e, t, r, n, i, s) {
        r = r || "message", n = n || "send", i = i || function() {}, s = s ? [ null ].concat(s) : [];
        var o = function(e) {
            s[0] = e, e = i(e), t[n].apply(t, s);
        };
        return e.on(r, o), {
            eventName: r,
            listener: o
        };
    }, osc.relayPorts = function(e, t, r) {
        var n = r.raw ? "raw" : "osc", i = r.raw ? "sendRaw" : "send";
        return osc.relay(e, t, n, i, r.transform);
    }, osc.stopRelaying = function(e, t) {
        e.removeListener(t.eventName, t.listener);
    }, osc.Relay = function(e, t, r) {
        (this.options = r || {}).raw = !1, this.port1 = e, this.port2 = t, this.listen();
    }, (e = osc.Relay.prototype = Object.create(EventEmitter.prototype)).constructor = osc.Relay, 
    e.open = function() {
        this.port1.open(), this.port2.open();
    }, e.listen = function() {
        this.port1Spec && this.port2Spec && this.close(), this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options), 
        this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);
        var e = this.close.bind(this);
        this.port1.on("close", e), this.port2.on("close", e);
    }, e.close = function() {
        osc.stopRelaying(this.port1, this.port1Spec), osc.stopRelaying(this.port2, this.port2Spec), 
        this.emit("close", this.port1, this.port2);
    }, "undefined" != typeof module && module.exports && (module.exports = osc);
}();

var osc = osc || require("../osc.js");

!function() {
    "use strict";
    osc.WebSocket = "undefined" != typeof WebSocket ? WebSocket : require("ws"), osc.WebSocketPort = function(e) {
        osc.Port.call(this, e), this.on("open", this.listen.bind(this)), this.socket = e.socket, 
        this.socket && (1 === this.socket.readyState ? (osc.WebSocketPort.setupSocketForBinary(this.socket), 
        this.emit("open", this.socket)) : this.open());
    };
    var e = osc.WebSocketPort.prototype = Object.create(osc.Port.prototype);
    e.constructor = osc.WebSocketPort, e.open = function() {
        (!this.socket || this.socket.readyState > 1) && (this.socket = new osc.WebSocket(this.options.url)), 
        osc.WebSocketPort.setupSocketForBinary(this.socket);
        var e = this;
        this.socket.onopen = function() {
            e.emit("open", e.socket);
        };
    }, e.listen = function() {
        var e = this;
        this.socket.onmessage = function(t) {
            e.emit("data", t.data, t);
        }, this.socket.onerror = function(t) {
            e.emit("error", t);
        }, this.socket.onclose = function(t) {
            e.emit("close", t);
        }, e.emit("ready");
    }, e.sendRaw = function(e) {
        this.socket && 1 === this.socket.readyState ? this.socket.send(e) : osc.fireClosedPortSendError(this);
    }, e.close = function(e, t) {
        this.socket.close(e, t);
    }, osc.WebSocketPort.setupSocketForBinary = function(e) {
        e.binaryType = osc.isNode ? "nodebuffer" : "arraybuffer";
    };
}();